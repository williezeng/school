######################################################################
# This file copyright the Georgia Institute of Technology
#
# Permission is given to students to use or modify this file (only)
# to work on their assignments.
#
# You may NOT publish this file or make it available to others not in
# the course.
#
######################################################################

import unittest
import multiprocessing as mproc
import traceback
import string
import sys
import copy
import io
import math
import random

try:
    from warehouse import DeliveryPlanner_PartB
    studentExc = None
except Exception as e:
    studentExc = e
    
########################################################################
# For debugging this flag can be set to True to print state 
# which could result in a timeout
########################################################################
VERBOSE_FLAG = False

########################################################################
# For debugging set the time limit to a big number (like 600 or more)
########################################################################
TIME_LIMIT = 5  # seconds

########################################################################
# If your debugger does not handle multiprocess debugging very easily
# then when debugging set the following flag true.
########################################################################
DEBUGGING_SINGLE_PROCESS = True

def truncate_output( s, max_len = 2000 ):
    if len(s) > max_len:
        return s[:max_len-70] + "\n***************** OUTPUT TRUNCATED DUE TO EXCESSIVE LENGTH!**************\n"
    else:
        return s

MOVE_DIRECTIONS = {"n":(-1,0),"ne":(-1,1),"e":(0,1),"se":(1,1),
                    "s":(1,0),"sw":(1,-1),"w":(0,-1),"nw":(-1,-1)}

class Submission:
    """Student Submission.

    Attributes:
        submission_score(Queue): Student score of last executed plan.
        submission_error(Queue): Error messages generated during last executed plan.
    """
    def __init__(self, fout=None):

        if DEBUGGING_SINGLE_PROCESS:
            import queue
            self.submission_score = queue.Queue(1)
            self.submission_error = queue.Queue(1)
            self.logmsgs = queue.Queue(1)
        else:
            self.submission_score = mproc.Manager().Queue(1)
            self.submission_error = mproc.Manager().Queue(1)
            self.logmsgs = mproc.Manager().Queue(1)

        self.fout = io.StringIO()

    def log(self, s):
        self.fout.write(s + '\n')

    def _reset(self):
        """Reset submission results.
        """
        while not self.submission_score.empty():
            self.submission_score.get()

        while not self.submission_error.empty():
            self.submission_error.get()

        while not self.logmsgs.empty():
            self.logmsgs.get()

    def _get_actions_from_policy(self, policy, robot_initial_position):
        """ Extract the set of actions from the policy generated by
            the student planner

        Args:
            policy(list(list)): the warehouse policy
            robot_initial_position (i,j): initial robot_position
        """

        i2,j2 = robot_initial_position
        li,lj = i2,j2
        moves = []

        # if there is a policy start moving through it from the initial
        # robot position
        if policy and len(policy[0]) > 0:
            # work through the policy but in case it never identifies
            # a position from which to lift the box, limit the total
            # possible moves

            # check that there is a valid policy defined at the initial robot location
            if not( 0 <= i2 < len(policy)) or not ( j2 < len( policy[0]) ) :
                raise Exception('Error in _get_actions_from_policy(): no policy defined at initial robot location (i,j)=({},{}))'.format(i2,j2))  

            while len( moves ) < 1000:
                i,j = i2,j2
                
                if not isinstance(policy[i][j],str):
                    raise Exception('Error in _get_actions_from_policy(): command is not of type string at (i,j) = ({},{}), action = {}'.format(i,j,policy[i][j]))
                elif len(policy[i][j]) == 0:
                    raise Exception('Error in _get_actions_from_policy(): no command at (i,j)=({},{})'.format(i,j))
                elif '-1' in policy[i][j]:
                    # Note to self, the initial robot location will never be on an actual wall
                    raise Exception("Error in _get_actions_from_policy(): last action is moving onto grid with '-1' (i,j) = ({},{}), action = {}".format(li,lj,policy[li][lj]))
    
                # extract the action
                action = policy[i][j].split()
    
                # append it to the list of moves
                moves.append( policy[i][j] )

                # check for the "final" move which will be a lift or down command
                if 'lift' in policy[i][j] or 'down' in policy[i][j] :
                    break

                # increment the robot postion according to the policy
                i2,j2 = i + MOVE_DIRECTIONS[action[1]][0], \
                        j + MOVE_DIRECTIONS[action[1]][1]

                # make sure this position exists in the policy
                if not( 0 <= i2 < len(policy)) or not ( j2 < len( policy[0]) ) :
                    raise Exception('Error in _get_actions_from_policy(): trying to move outside of warehouse at (i,j)=({},{}), action = {})'.format(i,j,policy[i][j]))  

                li,lj = i,j

 
        else:
            if not policy:
                raise Exception('Error in _get_actions_from_policy(): no policy')
            else:
                raise Exception('Error in _get_actions_from_policy(): policy appears to be empty')
        
        return moves
        
            
    def execute_student_plan(self, warehouse, warehouse_cost, robot_initial_position, boxes_todo):
        """Execute student plan and store results in submission.

        Args:
            warehouse(list(list)): the warehouse map to test against.
            warehouse_cost(list(list)): integer costs for each warehouse position
            robot_initial_position (i,j): initial position of robot 
            boxes_todo(list): the order of boxes to deliver.
        """
        self._reset()

        state = State(warehouse, warehouse_cost, robot_initial_position)

        try:
            student_planner = DeliveryPlanner_PartB(copy.deepcopy(warehouse), copy.deepcopy(warehouse_cost), copy.deepcopy(boxes_todo))
            search_policy, deliver_policy = student_planner.plan_delivery()

     
            # First follow the policy from wherever the robot has been dropped
            # to find the box
            search_actions = self._get_actions_from_policy( search_policy, robot_initial_position )

            if VERBOSE_FLAG:
                print("Search actions: ")
                for i in range(len(search_actions )):
                    print( search_actions[i])

            for action in search_actions:
                if VERBOSE_FLAG:
                    state.print_to_console( self.fout )

                if isinstance(action,str) and len(action) > 0:
                    state.update_according_to(action)

            # Now find the actions to take to deliver the box
            robot_initial_position = state.robot_position
            deliver_actions = self._get_actions_from_policy( deliver_policy, robot_initial_position )

            if VERBOSE_FLAG:
                print("Deliver actions: ")
                for i in range(len(deliver_actions )):
                    print( deliver_actions[i])
            
            num_delivered = 0
            next_box_to_deliver = boxes_todo[num_delivered]

            for action in deliver_actions:
                if VERBOSE_FLAG:
                    state.print_to_console( self.fout )

                state.update_according_to(action)

                # check if new box has been delivered
                delivered = state.get_boxes_delivered()
                if len(delivered) > num_delivered:
                    last_box_delivered = delivered[-1]
                    if last_box_delivered == next_box_to_deliver:
                        num_delivered += 1
                        if num_delivered < len(boxes_todo):
                            next_box_to_deliver = boxes_todo[num_delivered]
                        else:
                            # all boxes delivered: end test
                            break
                    else:
                        # wrong box delivered: kill test
                        raise Exception('wrong box delivered: {} instead of {}'.format(last_box_delivered,
                                                                                       next_box_to_deliver))

            if VERBOSE_FLAG:
                # print final state
                self.log('\n\n')
                self.log('Final State: ')
                state.print_to_console( self.fout )

            #Note, to receive credit, you must have deliverd all boxes.
            if num_delivered == len(boxes_todo):
               self.submission_score.put(state.get_total_cost())
            else:
               self.submission_score.put(float('inf')) 

        except Exception as err:
            if VERBOSE_FLAG:
                # very detailed stack trace - clutters everything up
                self.submission_error.put(traceback.format_exc())
            else:
                # slightly less cluttered output but the stack trace is much less informative
                self.submission_error.put(err)
            self.submission_score.put(float('inf'))

        self.logmsgs.put( truncate_output( self.fout.getvalue() ) )

class State:
    """Current State.

    Args:
        warehouse(list(list)): the warehouse map.
        warehouse_cost(list(list)): integer costs for each warehouse position
        robot_initial_position(i,j): robot's initial position

    Attributes:
        boxes_delivered(list): the boxes successfully delivered to dropzone.
        total_cost(int): the total cost of all moves executed.
        warehouse_state(list(list): the current warehouse state.
        dropzone(tuple(int, int)): the location of the dropzone.
        boxes(list): the location of the boxes.
        robot_position(tuple): the current location of the robot.
        box_held(str): ID of current box held.
    """
    ORTHOGONAL_MOVE_COST = 2
    DIAGONAL_MOVE_COST = 3
    BOX_LIFT_COST = 4
    BOX_DOWN_COST = 2
    ILLEGAL_MOVE_PENALTY = 100

    def __init__(self, warehouse, warehouse_cost, robot_initial_position):
        self.boxes_delivered = []
        self.total_cost = 0
        self.robot_position = copy.copy(robot_initial_position)

        self._set_initial_state_from(warehouse)
        self.warehouse_cost = warehouse_cost

    def _set_initial_state_from(self, warehouse):
        """Set initial state.

        Args:
            warehouse(list(list)): the warehouse map.
        """
        rows = len(warehouse)
        cols = len(warehouse[0])

        self.warehouse_state = [[None for j in range(cols)] for i in range(rows)]
        self.dropzone = None
        self.boxes = dict()

        for i in range(rows):
            for j in range(cols):
                this_square = warehouse[i][j]

                if this_square == '.':
                    self.warehouse_state[i][j] = '.'

                elif this_square == '#':
                    self.warehouse_state[i][j] = '#'

                elif this_square == '@':
                    self.warehouse_state[i][j] = '@'
                    self.dropzone = (i, j)

                else:  # a box
                    box_id = this_square
                    self.warehouse_state[i][j] = box_id
                    self.boxes[box_id] = (i, j)

        self.warehouse_state[self.robot_position[0]][self.robot_position[1]] = '*'
                  
        self.box_held = None

    def update_according_to(self, action):
        """Update state according to action.

        Args:
            action(str): action to execute.

        Raises:
            Exception: if improperly formatted action.
        """
        # what type of move is it?
        action = action.split()
        action_type = action[0]

        if action_type == 'move':
            direction = action[1]
            self._attempt_move(direction)

        elif action_type == 'lift':
            box = action[1]
            self._attempt_lift(box)

        elif action_type == 'down':
            direction = action[1]
            self._attempt_down(direction)

        else:
            # improper move format: kill test
            raise Exception('improperly formatted action: {}'.format(''.join(action)))

    def _attempt_move(self, direction):
        """Attempt move action if valid.

        The robot may not move outside the warehouse.
        The warehouse does not "wrap" around.
        Two spaces are considered adjacent if they share an edge or a corner.

        The robot may move horizontally or vertically at a cost of 2 per move.
        The robot may move diagonally at a cost of 3 per move.
        Illegal move (100 cost):
            attempting to move to a nonadjacent, nonexistent, or occupied space

        Args:
            direction: direction in which to move to adjacent square
                ("n","ne","e","se","s","sw","w","nw")
            

        Raises:
            ValueError: if improperly formatted move destination.
            IndexError: if move is outside of warehouse.
        """
        try:
              
            destination = MOVE_DIRECTIONS[direction][0] + self.robot_position[0], \
                         MOVE_DIRECTIONS[direction][1] + self.robot_position[1]

            destination_is_adjacent = self._are_adjacent(self.robot_position, destination)
            destination_is_traversable = self._is_traversable(destination)

            is_legal_move = destination_is_adjacent and destination_is_traversable

            if is_legal_move:
                self._move_robot_to(destination)
            else:
                self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

        except ValueError:
            raise Exception('improperly formatted move destination: {}'.format(direction))
        except IndexError:  # (row, col) not in warehouse
            self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

    def _attempt_lift(self, box_id):
        """Attempt lift action if valid.

        The robot may pick up a box that is in an adjacent square.
        The cost to pick up a box is 4, regardless of the direction the box is relative to the robot.
        While holding a box, the robot may not pick up another box.
        Illegal moves (100 cost):
            attempting to pick up a nonadjacent or nonexistent box
            attempting to pick up a box while holding one already

        Args:
            box_id(str): the id of the box to lift.

        Raises:
            KeyError: if invalid box id.
        """
        try:
            box_position = self.boxes[box_id]

            box_is_adjacent = self._are_adjacent(self.robot_position, box_position)
            robot_has_box = self._robot_has_box()

            is_legal_lift = box_is_adjacent and (not robot_has_box)
            if is_legal_lift:
                self._lift_box(box_id)
            else:
                self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

        except KeyError:
            self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

    def _attempt_down(self, direction):
        """Attempt down action if valid.

        The robot may put a box down on an adjacent empty space ('.') or the dropzone ('@') at a cost
            of 2 (regardless of the direction in which the robot puts down the box).
        Illegal moves (100 cost):
            attempting to put down a box on a nonadjacent, nonexistent, or occupied space
            attempting to put down a box while not holding one

        Args:
            direction: direction to adjacent square in which to set box down 
                  ("n","ne","e","se","s","sw","w","nw")

        Raises:
            ValueError: if improperly formatted down destination.
            IndexError: if down location is outside of warehouse.
        """
        try:

            destination = MOVE_DIRECTIONS[direction][0] + self.robot_position[0], \
                          MOVE_DIRECTIONS[direction][1] + self.robot_position[1]

            destination_is_adjacent = self._are_adjacent(self.robot_position, destination)
            destination_is_traversable = self._is_traversable(destination)
            robot_has_box = self._robot_has_box()

            is_legal_down = destination_is_adjacent and destination_is_traversable and robot_has_box
            if is_legal_down:
                self._down_box(destination)
            else:
                self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

        except ValueError:
            raise Exception('improperly formatted down destination: {}'.format(direction))
        except IndexError:  # (row, col) not in warehouse
            self._increase_total_cost_by(self.ILLEGAL_MOVE_PENALTY)

    def _increase_total_cost_by(self, amount):
        """Increase total move cost.

        Args:
            amount(int): amount to increase cost by.
        """
        self.total_cost += amount

    def _is_within_warehouse(self, coordinates):
        """Check if coordinates are within warehouse.

        Args:
            coordinates(tuple(int, int)): coordinates to test.

        Returns:
            True if within warehouse.
        """
        i, j = coordinates
        rows = len(self.warehouse_state)
        cols = len(self.warehouse_state[0])

        return (0 <= i < rows) and (0 <= j < cols)

    def _are_adjacent(self, coordinates1, coordinates2):
        """Verify if coordinates are adjacent.

        Args:
            coordinates1(tuple(int, int)): first coordinate.
            coordinates2(tuple(int, int)): second coordinate.

        Returns:
            True if adjacent in all directions.
        """
        return (self._are_horizontally_adjacent(coordinates1, coordinates2) or
                self._are_vertically_adjacent(coordinates1, coordinates2) or
                self._are_diagonally_adjacent(coordinates1, coordinates2)
                )

    @staticmethod
    def _are_horizontally_adjacent(coordinates1, coordinates2):
        """Verify if coordinates are horizontally adjacent.

        Args:
            coordinates1(tuple(int, int)): first coordinate.
            coordinates2(tuple(int, int)): second coordinate.

        Returns:
            True if horizontally adjacent.
        """
        row1, col1 = coordinates1
        row2, col2 = coordinates2

        return (row1 == row2) and (abs(col1 - col2) == 1)

    @staticmethod
    def _are_vertically_adjacent(coordinates1, coordinates2):
        """Verify if coordinates are vertically adjacent.

        Args:
            coordinates1(tuple(int, int)): first coordinate.
            coordinates2(tuple(int, int)): second coordinate.

        Returns:
            True if vertically adjacent.
        """
        row1, col1 = coordinates1
        row2, col2 = coordinates2

        return (abs(row1 - row2) == 1) and (col1 == col2)

    @staticmethod
    def _are_diagonally_adjacent(coordinates1, coordinates2):
        """Verify if coordinates are diagonally adjacent.

        Args:
            coordinates1(tuple(int, int)): first coordinate.
            coordinates2(tuple(int, int)): second coordinate.

        Returns:
            True if diagonally adjacent.
        """
        row1, col1 = coordinates1
        row2, col2 = coordinates2

        return (abs(row1 - row2) == 1) and (abs(col1 - col2) == 1)

    def _is_traversable(self, coordinates):
        """Verify if space is traversable.

        Args:
            coordinates(tuple(int, int)): coordinate to check.

        Return:
            True if traversable.
        """
        is_wall = self._is_wall(coordinates)
        has_box = self._space_contains_box(coordinates)

        return (not is_wall) and (not has_box)

    def _is_wall(self, coordinates):
        """Verify if space is wall.

        Args:
            coordinates(tuple(int, int)): coordinate to check.

        Return:
            True if wall.
        """
        i, j = coordinates

        return self.warehouse_state[i][j] == '#'

    def _space_contains_box(self, coordinates):
        """Verify if space contains box.

        Args:
            coordinates(tuple(int, int)): coordinate to check.

        Return:
            True if space contains box.
        """
        i, j = coordinates

        return self.warehouse_state[i][j] in (string.ascii_letters + string.digits)

    def _robot_has_box(self):
        """Verify if robot has box.

        Returns:
            True if box is being held.
        """
        return self.box_held is not None

    def _move_robot_to(self, destination):
        """Execute move.

        Args:
            destination(tuple(int, int)): location to set box down at.
        """
        old_position = self.robot_position
        self.robot_position = destination

        i1, j1 = old_position
        if self.dropzone == old_position:
            self.warehouse_state[i1][j1] = '@'
        else:
            self.warehouse_state[i1][j1] = '.'

        i2, j2 = destination
        self.warehouse_state[i2][j2] = '*'

        if self._are_diagonally_adjacent(old_position, destination):
            self._increase_total_cost_by(self.DIAGONAL_MOVE_COST)
        else:
            self._increase_total_cost_by(self.ORTHOGONAL_MOVE_COST)

        # Account for the cost of each square
        self._increase_total_cost_by(self.warehouse_cost[i2][j2])

    def _lift_box(self, box_id):
        """Execute lift box.

        Args:
            box_id(str): the id of the box to lift.
        """
        i, j = self.boxes[box_id]
        self.warehouse_state[i][j] = '.'

        self.boxes.pop(box_id)

        self.box_held = box_id

        self._increase_total_cost_by(self.BOX_LIFT_COST + self.warehouse_cost[i][j])

    def _down_box(self, destination):
        """Execute box down.

        Args:
            destination(tuple(int, int)): location to set box down at.
        """
        # - If a box is placed on the '@' space, it is considered delivered and is removed from the ware-
        #   house.
        i, j = destination

        if self.warehouse_state[i][j] == '.':
            self.warehouse_state[i][j] = self.box_held
            self.boxes[self.box_held] = (i, j)
        else:
            self._deliver_box(self.box_held)

        self.box_held = None
        self._increase_total_cost_by(self.BOX_DOWN_COST + self.warehouse_cost[i][j])

    def _deliver_box(self, box_id):
        """Mark box delivered.

        Args:
            box_id(str): id of box to mark delivered.
        """
        self.boxes_delivered.append(box_id)

    def get_boxes_delivered(self):
        """Get list of boxes delivered.

        Returns:
            List of boxes delivered.
        """
        return self.boxes_delivered

    def get_total_cost(self):
        """Get current total cost.

        Returns:
            Total cost of all executed moves.
        """
        return self.total_cost

    def print_to_console(self, fout=None):
        """Print current state to console.
        """
        my_fout = fout or sys.stdout
        my_fout.write("\n")
        for row in self.warehouse_state:
            my_fout.write( ''.join(str(row)) + '\n' )
        my_fout.write( 'total cost: %.02f\n' % self.total_cost )
        my_fout.write( 'box held: %s\n' % str(self.box_held) )
        my_fout.write( 'delivered: %s\n' % str(self.boxes_delivered) )
        my_fout.write( '\n' )


class PartBTestCase(unittest.TestCase):
    """ Test Part B.
    """

    results = ['', 'PART B TEST CASE RESULTS']
    SCORE_TEMPLATE = "\n".join((
        "\n-----------",
        "Test Case {test_case}",
        "Output: {output}",
        "cost: {cost:.2f}  (expected min {min_cost:.2f})",
        "credit: {score:.2f}"
    ))
    FAIL_TEMPLATE = "\n".join((
        "\n-----------",
        "Test Case {test_case}",
        "Output: {output}",
        "Failed: {message}",
        "credit: 0"
    ))

    credit = []
    totalCredit = 0

    fout = None

    @classmethod
    def _log(cls, s):
        (cls.fout or sys.stdout).write( s + '\n')

    def setUp(self):
        """Initialize test setup.
        """
        if studentExc:
            self.credit.append( 0.0 )
            self.results.append( "exception on import: %s" % str(studentExc) )
            raise studentExc

        self.student_submission = Submission( fout = self.__class__.fout )

    def tearDown(self):
        self.__class__.totalCredit = sum(self.__class__.credit)

    @classmethod
    def tearDownClass(cls):
        """Save student results at conclusion of test.
        """
        # Prints results after all tests complete
        for line in cls.results:
            cls._log(line)
        cls._log("\n-----------")
        cls._log('\nTotal Credit: {:.2f}'.format(cls.totalCredit))


    def check_results(self, params):

        error_message = ''
        cost = float('inf')
        score = 0.0
        logmsg = ''

        if not self.student_submission.logmsgs.empty():
            logmsg = self.student_submission.logmsgs.get()

        if not self.student_submission.submission_score.empty():
            cost = self.student_submission.submission_score.get()

        score = float(params['min_cost']) / float(cost)

        if not self.student_submission.submission_error.empty():
            error_message = self.student_submission.submission_error.get()
            self.results.append(self.FAIL_TEMPLATE.format(message=error_message, output = logmsg, **params))

        else:
            self.results.append(self.SCORE_TEMPLATE.format(cost=cost, score=score, output = logmsg, **params))

        self.credit.append(score)

        self._log('test case {} credit: {}'.format(params['test_case'], score))
        if error_message:
            self._log('{}'.format(error_message))

        self.assertFalse(error_message, error_message)

    def run_with_params(self, params):
        """Run test case using desired parameters.

        Args:
            params(dict): a dictionary of test parameters.
        """

        if DEBUGGING_SINGLE_PROCESS:
            self.student_submission.execute_student_plan(params['warehouse'], params['warehouse_cost'], 
                                    params['robot_init'], params['todo'])
        else:
            test_process = mproc.Process(target=self.student_submission.execute_student_plan, args=(params['warehouse'],
                                params['warehouse_cost'], params['robot_init'], params['todo']))

        if DEBUGGING_SINGLE_PROCESS :

            # Note: no TIMEOUT is checked in this case so that debugging isn't 
            # inadvertently stopped

            self.check_results( params )

        else:

            logmsg = ''

            try:
                test_process.start()
                test_process.join(TIME_LIMIT)
            except Exception as exp:
                error_message = exp

            if test_process.is_alive():
                test_process.terminate()
                error_message = ('Test aborted due to timeout. ' +
                                'Test was expected to finish in fewer than {} second(s).'.format(TIME_LIMIT))
                if not self.student_submission.logmsgs.empty():
                    logmsg = self.student_submission.logmsgs.get()
                self.results.append(self.FAIL_TEMPLATE.format(message=error_message, output = logmsg, **params))

            else:

                self.check_results( params )
   
    def test_case1(self):
        params = {'test_case': 1,
                  'warehouse': ['1..',
                                '.#.',
                                '..@'],
                  'warehouse_cost': [ [3, 5, 2],
					                    [10, math.inf, 2],
					                    [2, 10, 2]],
                  'todo': ['1'],
                  'robot_init':(0,2),
                  'min_cost': 23}

        self.run_with_params(params)

    # Notice that we have included several extra test cases below.
    # You can uncomment one or more of these for extra tests.

    def test_case2(self):
        params = {'test_case': 2,
                  'warehouse': ['1..',
                                '.#.',
                                '..@'],
                  'warehouse_cost': [[3, 25, 2],
					                 [10, math.inf, 2],
					                 [2, 10, 2]],
                  'todo': ['1'],
                  'robot_init':(2,1),
                  'min_cost': 37}

        self.run_with_params(params)

    def test_case3(self):
        params = {'test_case': 3,
                  'warehouse': ['##.####1',
                                '#.......',
                                '@.......'],
                  'warehouse_cost':[[math.inf, math.inf,3,math.inf,math.inf,math.inf,math.inf,12],
                                    [math.inf,        8, 10,   2, 10,   4, 15, 8],
                                    [       15,      10, 10, 10,   7, 10,  2, 10]],
                  'robot_init':(0,2),
                  'todo': ['1'],
                  'min_cost': 115.0}
    
        self.run_with_params(params)
    
    def test_case4(self):
        params = {'test_case': 4,
                  'warehouse': ['.........#..........',
                                '...#.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,math.inf,10,12,98,45,30,2,3,100,2,44],
                                [82,79,61,math.inf,78,59,19,11,23,math.inf,91,14,1,64,62,31,8,85,69,59],
                                [0,8,76,math.inf,86,11,65,74,5,34,71,8,82,38,61,45,34,31,83,25],
                                [58,67,85,math.inf,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20],
                                [9,71,27,18,math.inf,3,44,98,14,math.inf,math.inf,math.inf,math.inf,math.inf,67,18,85,39,math.inf,math.inf],
                                [58,5,53,35,84,5,math.inf,22,34,math.inf,19,38,19,99,59,5,72,49,97,44],
                                [63,43,74,59,60,5,math.inf,100,60,math.inf,76,21,56,0,93,99,66,56,37,35]],
                  'todo': ['1'],
                  'robot_init':(6,19),
                  'min_cost': 824}
    
        self.run_with_params(params)

    def test_case5(self):
        params = {'test_case': 5,
                  'warehouse': ['.........#..........',
                                '####.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,math.inf,10,12,98,45,30,2,3,100,2,44],
                                [math.inf,math.inf,math.inf,math.inf,78,59,19,11,23,math.inf,91,14,1,64,62,31,8,85,69,59],
                                [0,8,76,math.inf,86,11,65,74,5,34,71,8,82,38,61,45,34,31,83,25],
                                [58,67,85,math.inf,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20],
                                [9,71,27,18,math.inf,3,44,98,14,math.inf,math.inf,math.inf,math.inf,math.inf,67,18,85,39,math.inf,math.inf],
                                [58,5,53,35,84,5,math.inf,22,34,math.inf,19,38,19,99,59,5,72,49,97,44],
                                [63,43,74,59,60,5,math.inf,100,60,math.inf,76,21,56,0,93,99,66,56,37,35]],
                  'todo': ['1'],
                  'robot_init':(0,1),
                  'min_cost': 577}
    
        self.run_with_params(params)

    def test_case6(self):
        params = {'test_case': 6,
                  'warehouse': ['.........#..........',
                                '..##.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,math.inf,10,12,98,45,30,2,3,100,2,44],
                                [1,37,math.inf,math.inf,78,59,19,11,23,math.inf,91,14,1,64,62,31,8,85,69,59],
                                [0,8,76,math.inf,86,11,65,74,5,34,71,8,82,38,61,45,34,31,83,25],
                                [58,67,85,math.inf,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20],
                                [9,71,27,18,math.inf,3,44,98,14,math.inf,math.inf,math.inf,math.inf,math.inf,67,18,85,39,math.inf,math.inf],
                                [58,5,53,35,84,5,math.inf,22,34,math.inf,19,38,19,99,59,5,72,49,97,44],
                                [63,43,74,59,60,5,math.inf,100,60,math.inf,76,21,56,0,93,99,66,56,37,35]],
                  'todo': ['1'],
                  'robot_init':(2,19),
                  'min_cost': 792}
    
        self.run_with_params(params)

    def test_case7(self):
        params = {'test_case': 7,
                  'warehouse': ['.........#..........',
                                '..##.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,math.inf,10,12,98,45,30,2,3,100,2,44],
                                [1,37,math.inf,math.inf,78,59,19,11,23,math.inf,91,14,1,64,62,31,8,85,69,59],
                                [0,8,76,math.inf,86,11,65,74,5,34,71,8,82,38,61,45,34,31,83,25],
                                [58,67,85,math.inf,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20],
                                [9,71,27,18,math.inf,3,44,98,14,math.inf,math.inf,math.inf,math.inf,math.inf,67,18,85,39,math.inf,math.inf],
                                [58,5,53,35,84,5,math.inf,22,34,math.inf,19,38,19,99,59,5,72,49,97,44],
                                [63,43,74,59,60,5,math.inf,100,60,math.inf,76,21,56,0,93,99,66,56,37,35]],
                  'todo': ['1'],
                  'robot_init':(0,8),
                  'min_cost': 541}
    
        self.run_with_params(params)


    def test_case8(self):
        params = {'test_case': 8,
                'warehouse': ['............#...............',
                              '......#.....#...............',
                              '.....................#......',
                              '............................',
                              '..1...#.....................',
                              '............##########......',
                              '......#..#..#.........#.....',
                              '.........#..#....@....#.....',
                              '......#.....#.........#.....',
                              '............#.........#.....'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,10,12,98,math.inf,45,30,2,3,100,2,44,82,79,61,78,59,19,11,23],
                                  [91,14,1,64,62,31,math.inf,8,85,69,59,8,math.inf,76,86,11,65,74,5,34,71,8,82,38,61,45,34,31],
                                  [83,25,58,67,85,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20,math.inf,9,71,27,18,3,44],
                                  [98,14,67,18,85,39,58,5,53,35,84,5,22,34,19,38,19,99,59,5,72,49,97,44,63,43,74,59],
                                  [60,5,100,60,76,21,math.inf,56,93,99,66,56,37,35,15,99,23,53,55,98,15,67,13,62,48,84,32,82],
                                  [24,44,13,89,89,20,74,34,19,92,41,100,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,57,92,9,10,50,27],
                                  [6,36,4,28,64,11,math.inf,89,40,math.inf,39,58,math.inf,8,74,32,9,88,54,25,12,50,math.inf,24,90,58,64,30],
                                  [46,26,65,89,53,22,74,26,38,math.inf,7,45,math.inf,68,19,63,98,70,60,42,17,16,math.inf,6,79,21,18,69],
                                  [8,91,41,21,0,85,math.inf,86,7,81,11,97,math.inf,18,27,5,55,50,94,41,26,86,math.inf,48,35,68,80,38],
                                  [54,40,87,73,19,68,11,97,33,35,52,51,math.inf,72,35,67,14,89,48,35,27,38,math.inf,91,75,50,6,44]],
                  'todo': ['1'],
                  'robot_init':(1,27),
                  'min_cost': 1309}
    
        self.run_with_params(params)

    def test_case9(self):
        params = {'test_case': 9,
                'warehouse': ['............#...............',
                              '......#.....#...............',
                              '.....................#......',
                              '............................',
                              '..1...#.....................',
                              '............##########......',
                              '......#..#..#.........#.....',
                              '.........#..#....@....#.....',
                              '......#.....#.........#.....',
                              '............#.........#.....'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,10,12,98,math.inf,45,30,2,3,100,2,44,82,79,61,78,59,19,11,23],
                                  [91,14,1,64,62,31,math.inf,8,85,69,59,8,math.inf,76,86,11,65,74,5,34,71,8,82,38,61,45,34,31],
                                  [83,25,58,67,85,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20,math.inf,9,71,27,18,3,44],
                                  [98,14,67,18,85,39,58,5,53,35,84,5,22,34,19,38,19,99,59,5,72,49,97,44,63,43,74,59],
                                  [60,5,100,60,76,21,math.inf,56,93,99,66,56,37,35,15,99,23,53,55,98,15,67,13,62,48,84,32,82],
                                  [24,44,13,89,89,20,74,34,19,92,41,100,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,57,92,9,10,50,27],
                                  [6,36,4,28,64,11,math.inf,89,40,math.inf,39,58,math.inf,8,74,32,9,88,54,25,12,50,math.inf,24,90,58,64,30],
                                  [46,26,65,89,53,22,74,26,38,math.inf,7,45,math.inf,68,19,63,98,70,60,42,17,16,math.inf,6,79,21,18,69],
                                  [8,91,41,21,0,85,math.inf,86,7,81,11,97,math.inf,18,27,5,55,50,94,41,26,86,math.inf,48,35,68,80,38],
                                  [54,40,87,73,19,68,11,97,33,35,52,51,math.inf,72,35,67,14,89,48,35,27,38,math.inf,91,75,50,6,44]],
                  'todo': ['1'],
                  'robot_init':(9,17),
                  'min_cost': 1484}
    
        self.run_with_params(params)
   
    def test_case10(self):
        params = {'test_case': 10,
                'warehouse': ['............#...............',
                              '......#.....#...............',
                              '.....................#......',
                              '............................',
                              '......#.....................',
                              '............##########......',
                              '......#..#..#.........#.....',
                              '.........#..#....@....#.....',
                              '......#.....#....1....#.....',
                              '............#.........#.....'],
                'warehouse_cost':[[99,56,14,0,11,74,4,85,88,10,12,98,math.inf,45,30,2,3,100,2,44,82,79,61,78,59,19,11,23],
                                  [91,14,1,64,62,31,math.inf,8,85,69,59,8,math.inf,76,86,11,65,74,5,34,71,8,82,38,61,45,34,31],
                                  [83,25,58,67,85,2,65,9,0,42,18,90,60,84,48,21,6,9,75,63,20,math.inf,9,71,27,18,3,44],
                                  [98,14,67,18,85,39,58,5,53,35,84,5,22,34,19,38,19,99,59,5,72,49,97,44,63,43,74,59],
                                  [60,5,100,60,76,21,math.inf,56,93,99,66,56,37,35,15,99,23,53,55,98,15,67,13,62,48,84,32,82],
                                  [24,44,13,89,89,20,74,34,19,92,41,100,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,math.inf,57,92,9,10,50,27],
                                  [ 6,36, 4,28,64,11,math.inf,89,40,math.inf,39,58,math.inf, 8,74,32, 9,88,54,25,12,50,math.inf,24,90,58,64,30],
                                  [46,26,65,89,53,22,74,26,38,math.inf, 7,45,math.inf,68,19,63,98,70,60,42,17,16,math.inf,6,79,21,18,69],
                                  [ 8,91,41,21, 0,85,math.inf,86,7,81,11,97,math.inf,18,27, 5,55,50,94,41,26,86,math.inf,48,35,68,80,38],
                                  [54,40,87,73,19,68,11,97,33,35,52,51,math.inf,72,35,67,14,89,48,35,27,38,math.inf,91,75,50,6,44]],
                  'todo': ['1'],
                  'robot_init':(7,17),
                  'min_cost': 138}
    
        self.run_with_params(params)


# Only run all of the test automatically if this file was executed from the command line.
# Otherwise, let Nose/py.test do it's own thing with the test cases.
if __name__ == "__main__":
    PartBTestCase.fout = sys.stdout
    unittest.main()
